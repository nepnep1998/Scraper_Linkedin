from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time
import json
import os
import pandas as pd
import re
from urllib.parse import unquote

class LinkedInScraperPro:
    def __init__(self):
        self.setup_driver()
        self.wait = WebDriverWait(self.driver, 15)
    
    def setup_driver(self):
        """Configura o ChromeDriver"""
        print("üîß CONFIGURANDO NAVEGADOR...")
        
        chrome_options = Options()
        chrome_options.add_argument("--disable-blink-features=AutomationControlled")
        chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
        chrome_options.add_argument("--no-sandbox")
        chrome_options.add_argument("--disable-dev-shm-usage")
        chrome_options.add_argument("--log-level=3")
        
        try:
            service = Service(ChromeDriverManager().install())
            self.driver = webdriver.Chrome(service=service, options=chrome_options)
            self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
            print("‚úÖ NAVEGADOR CONFIGURADO!")
            
        except Exception as e:
            print(f"‚ùå Erro ao configurar navegador: {e}")
            raise

    def login_linkedin(self):
        """Faz login no LinkedIn"""
        print("\nüîê INICIANDO LOGIN")
        print("=" * 40)
        
        self.driver.get("https://www.linkedin.com/login")
        time.sleep(3)
        
        print("üìã INSTRU√á√ïES:")
        print("1. Fa√ßa login MANUALMENTE")
        print("2. Aguarde a p√°gina inicial") 
        print("3. Pressione ENTER")
        print("=" * 40)
        
        input("‚úÖ PRESSIONE ENTER AP√ìS LOGIN...")
        return True

    def get_dynamic_profile_data(self, profile_url):
        """Coleta dados APENAS do perfil, ignorando feed/interface"""
        try:
            print(f"\nüöÄ ACESSANDO PERFIL: {profile_url}")
            self.driver.get(profile_url)
            time.sleep(5)
            
            # üéØ VERIFICA SE EST√Å NA P√ÅGINA CORRETA
            if not self.is_profile_page():
                print("‚ùå N√£o est√° na p√°gina do perfil! Redirecionando...")
                return None
            
            # Foca apenas na √°rea principal do perfil
            profile_section = self.get_profile_main_section()
            
            if not profile_section:
                print("‚ùå N√£o conseguiu encontrar a se√ß√£o principal do perfil")
                return None
            
            # Coleta dados APENAS da se√ß√£o do perfil
            profile_data = {
                "url": profile_url,
                "nome": self.get_profile_name(profile_section),
                "cargo_atual": self.get_profile_headline(profile_section),
                "localizacao": self.get_profile_location(profile_section),
                "sobre": self.get_profile_about(profile_section),
                "experiencia_principal": self.get_profile_experience(profile_section),
                "formacao_academica": self.get_profile_education(profile_section),
                "competencias_principais": self.get_precise_skills(),  # üÜï M√âTODO PRECISO
                "coletado_em": time.strftime("%d/%m/%Y %H:%M:%S")
            }
            
            print("‚úÖ DADOS COLETADOS DO PERFIL!")
            return profile_data
            
        except Exception as e:
            print(f"‚ùå ERRO: {e}")
            return None

    def is_profile_page(self):
        """Verifica se est√° realmente na p√°gina de perfil"""
        try:
            # Verifica se tem elementos espec√≠ficos de perfil
            profile_indicators = [
                "//main[contains(@class, 'scaffold-layout__main')]",
                "//div[contains(@class, 'pv-profile-page')]",
                "//section[contains(@class, 'pv-profile-section')]"
            ]
            
            for indicator in profile_indicators:
                if len(self.driver.find_elements(By.XPATH, indicator)) > 0:
                    return True
            
            # Verifica pela URL
            current_url = self.driver.current_url
            if '/in/' in current_url and 'feed' not in current_url:
                return True
                
            return False
        except:
            return False

    def get_profile_main_section(self):
        """Encontra a se√ß√£o principal do perfil"""
        try:
            # Tenta encontrar a √°rea principal do perfil
            main_selectors = [
                "main.scaffold-layout__main",
                "div.pv-profile-page",
                "div.profile",
                "#main-content",
                "main"
            ]
            
            for selector in main_selectors:
                try:
                    if selector.startswith("//"):
                        element = self.driver.find_element(By.XPATH, selector)
                    else:
                        element = self.driver.find_element(By.CSS_SELECTOR, selector)
                    return element
                except:
                    continue
            
            # Fallback: pega o body mas filtra depois
            return self.driver.find_element(By.TAG_NAME, "body")
        except:
            return None

    def get_profile_name(self, profile_section):
        """Busca nome APENAS na se√ß√£o do perfil"""
        try:
            name_selectors = [
                ".//h1[contains(@class, 'text-heading-xlarge')]",
                ".//h1[contains(@class, 'top-card-layout__title')]",
                ".//h1"
            ]
            
            for selector in name_selectors:
                try:
                    element = profile_section.find_element(By.XPATH, selector)
                    text = element.text.strip()
                    if text and len(text) > 1:
                        return text
                except:
                    continue
            return "N√£o informado"
        except:
            return "N√£o informado"

    def get_profile_headline(self, profile_section):
        """Busca cargo APENAS na se√ß√£o do perfil"""
        try:
            headline_selectors = [
                ".//div[contains(@class, 'text-body-medium')]",
                ".//div[contains(@class, 'top-card-layout__headline')]",
                ".//h2[contains(@class, 'mt1')]"
            ]
            
            for selector in headline_selectors:
                try:
                    element = profile_section.find_element(By.XPATH, selector)
                    text = element.text.strip()
                    if text and len(text) > 5:
                        return text
                except:
                    continue
            return "N√£o informado"
        except:
            return "N√£o informado"

    def get_profile_location(self, profile_section):
        """Busca localiza√ß√£o APENAS na se√ß√£o do perfil"""
        try:
            # Busca espec√≠fica na √°rea de informa√ß√µes b√°sicas
            location_selectors = [
                ".//span[contains(@class, 'text-body-small')]",
                ".//div[contains(@class, 'pv-text-details__left-panel')]//span"
            ]
            
            for selector in location_selectors:
                try:
                    elements = profile_section.find_elements(By.XPATH, selector)
                    for element in elements:
                        text = element.text.strip()
                        if (text and 
                            any(loc in text.lower() for loc in ['manaus', 'amazonas', 'brasil', 'brazil', 'portugal', 's√£o paulo', 'rio']) and
                            not any(exclude in text.lower() for exclude in ['conex√µes', 'seguidores', 'contato'])):
                            return text
                except:
                    continue
            return "Localiza√ß√£o n√£o encontrada"
        except:
            return "Localiza√ß√£o n√£o encontrada"

    def get_profile_about(self, profile_section):
        """Busca se√ß√£o SOBRE APENAS no perfil"""
        try:
            # Busca pela se√ß√£o "Sobre" espec√≠fica
            about_selectors = [
                ".//section[.//h2[contains(., 'Sobre') or contains(., 'About')]]",
                ".//div[contains(@id, 'about')]",
                ".//div[contains(@class, 'pv-about-section')]"
            ]
            
            for selector in about_selectors:
                try:
                    about_section = profile_section.find_element(By.XPATH, selector)
                    # Pega todo o texto da se√ß√£o
                    text = about_section.text.strip()
                    
                    # Remove o t√≠tulo "Sobre" e limpa
                    lines = text.split('\n')
                    clean_lines = []
                    for line in lines:
                        line_clean = line.strip()
                        if (line_clean and 
                            line_clean.lower() not in ['sobre', 'about'] and
                            len(line_clean) > 20):
                            clean_lines.append(line_clean)
                    
                    if clean_lines:
                        return '\n'.join(clean_lines)
                except:
                    continue
            return "Se√ß√£o n√£o encontrada"
        except:
            return "Se√ß√£o n√£o encontrada"

    def get_profile_experience(self, profile_section):
        """Busca EXPERI√äNCIA APENAS no perfil"""
        try:
            experience_data = []
            
            # Busca pela se√ß√£o de experi√™ncia
            exp_selectors = [
                ".//section[.//h2[contains(., 'Experi√™ncia') or contains(., 'Experience')]]",
                ".//div[contains(@id, 'experience')]",
                ".//div[contains(@class, 'pv-experience-section')]"
            ]
            
            for selector in exp_selectors:
                try:
                    exp_section = profile_section.find_element(By.XPATH, selector)
                    
                    # Busca itens de experi√™ncia
                    items = exp_section.find_elements(By.XPATH, ".//li | .//div[contains(@class, 'pv-entity')]")[:5]
                    
                    for item in items:
                        text = item.text.strip()
                        if text and len(text) > 30:
                            # Filtra apenas conte√∫do relevante
                            clean_text = self.clean_experience_text(text)
                            if clean_text and clean_text not in experience_data:
                                experience_data.append(clean_text)
                    
                    if experience_data:
                        return experience_data
                except:
                    continue
            
            return ["Experi√™ncia n√£o encontrada"]
        except:
            return ["Erro ao buscar experi√™ncia"]

    def get_profile_education(self, profile_section):
        """Busca FORMA√á√ÉO APENAS no perfil"""
        try:
            education_data = []
            
            # Busca pela se√ß√£o de educa√ß√£o
            edu_selectors = [
                ".//section[.//h2[contains(., 'Forma√ß√£o acad√™mica') or contains(., 'Education')]]",
                ".//div[contains(@id, 'education')]",
                ".//div[contains(@class, 'pv-education-section')]"
            ]
            
            for selector in edu_selectors:
                try:
                    edu_section = profile_section.find_element(By.XPATH, selector)
                    
                    # Busca itens de educa√ß√£o
                    items = edu_section.find_elements(By.XPATH, ".//li | .//div[contains(@class, 'pv-entity')]")[:5]
                    
                    for item in items:
                        text = item.text.strip()
                        if text and len(text) > 20:
                            clean_text = self.clean_education_text(text)
                            if clean_text and clean_text not in education_data:
                                education_data.append(clean_text)
                    
                    if education_data:
                        return education_data
                except:
                    continue
            
            return ["Forma√ß√£o n√£o encontrada"]
        except:
            return ["Erro ao buscar forma√ß√£o"]

    def get_precise_skills(self):
        """üÜï M√âTODO PRECISO - Foca APENAS na se√ß√£o de compet√™ncias"""
        try:
            print("üõ†Ô∏è  Buscando COMPET√äNCIAS (abordagem precisa)...")
            
            # üéØ ESTRAT√âGIA 1: Busca DIRETA pela se√ß√£o de compet√™ncias
            skills_section = self.find_skills_section()
            if not skills_section:
                return ["Compet√™ncias n√£o encontradas"]
            
            # üéØ ESTRAT√âGIA 2: Expande a se√ß√£o se necess√°rio
            self.expand_skills_section(skills_section)
            time.sleep(2)
            
            # üéØ ESTRAT√âGIA 3: Busca compet√™ncias DENTRO da se√ß√£o correta
            skills_data = self.extract_skills_from_section(skills_section)
            
            return skills_data[:10] if skills_data else ["Compet√™ncias n√£o encontradas"]
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro em compet√™ncias precisas: {e}")
            return ["Erro ao buscar compet√™ncias"]

    def find_skills_section(self):
        """Encontra a se√ß√£o espec√≠fica de compet√™ncias"""
        try:
            # üéØ SELE√á√ÉO PRECISA - APENAS se√ß√µes que S√ÉO compet√™ncias
            skills_selectors = [
                # Se√ß√£o principal de compet√™ncias
                "//section[.//h2[contains(., 'Compet√™ncias') or contains(., 'Skills') or contains(., 'Conhecimentos')]]",
                "//div[contains(@id, 'skills')]",
                
                # Se√ß√µes com estrutura de compet√™ncias
                "//section[.//div[contains(@class, 'pv-skill-category-entity')]]",
                "//section[.//span[contains(@class, 'pv-skill-category-entity__name')]]",
                
                # √Årea de compet√™ncias do perfil
                "//div[contains(@class, 'pv-profile-content')]//section[.//*[contains(text(), 'Mapas') or contains(text(), 'SIG')]]"
            ]
            
            for selector in skills_selectors:
                try:
                    section = self.driver.find_element(By.XPATH, selector)
                    print(f"‚úÖ Se√ß√£o de compet√™ncias encontrada: {selector}")
                    return section
                except:
                    continue
            
            print("‚ùå Nenhuma se√ß√£o de compet√™ncias encontrada")
            return None
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao encontrar se√ß√£o: {e}")
            return None

    def expand_skills_section(self, skills_section):
        """Expande a se√ß√£o de compet√™ncias se houver bot√µes 'ver mais'"""
        try:
            # Busca bot√µes de expandir DENTRO da se√ß√£o de compet√™ncias
            expand_buttons = skills_section.find_elements(By.XPATH, 
                ".//button[contains(., 'ver mais') or contains(., 'Ver mais') or contains(., 'see more') or contains(., 'Exibir todas')]"
            )
            
            for button in expand_buttons:
                try:
                    if button.is_displayed():
                        self.driver.execute_script("arguments[0].click();", button)
                        time.sleep(1)
                        print("‚úÖ Se√ß√£o de compet√™ncias expandida")
                except:
                    continue
                    
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao expandir se√ß√£o: {e}")

    def extract_skills_from_section(self, skills_section):
        """Extrai compet√™ncias APENAS da se√ß√£o correta - FOCANDO NOS SPANS ESPEC√çFICOS"""
        try:
            skills_data = []
            
            # üéØ BUSCA ESPEC√çFICA PELOS SPANS EXATOS DO LINKEDIN
            span_selectors = [
                ".//span[@aria-hidden='true']",
                ".//span[contains(@class, 'pv-skill-category-entity__name-text')]"
            ]
            
            print("üîç Buscando spans com nomes de compet√™ncias...")
            
            for selector in span_selectors:
                try:
                    elements = skills_section.find_elements(By.XPATH, selector)
                    print(f"üìå Encontrados {len(elements)} elementos span")
                    
                    for element in elements:
                        text = element.text.strip()
                        if text and self.is_valid_skill_title(text):
                            # Verifica se √© um nome de compet√™ncia v√°lido
                            skills_data.append(text)
                            print(f"‚úÖ Compet√™ncia encontrada: {text}")
                    
                except Exception as e:
                    print(f"‚ö†Ô∏è  Erro ao buscar com {selector}: {e}")
                    continue
            
            # üéØ ALTERNATIVA: Busca por textos espec√≠ficos de compet√™ncias
            if not skills_data:
                print("üîç Tentando busca alternativa por compet√™ncias...")
                alternative_selectors = [
                    ".//*[contains(text(), 'Mapas')]",
                    ".//*[contains(text(), 'SIG')]",
                    ".//*[contains(text(), 'An√°lise espacial')]",
                    ".//h3[contains(@class, 't-16')]",
                    ".//div[contains(@class, 'pv-skill-category-entity__name')]"
                ]
                
                for selector in alternative_selectors:
                    try:
                        elements = skills_section.find_elements(By.XPATH, selector)
                        for element in elements:
                            text = element.text.strip()
                            if text and self.is_valid_skill_title(text):
                                skills_data.append(text)
                                print(f"‚úÖ Compet√™ncia alternativa: {text}")
                    except:
                        continue
            
            # üéØ FILTRAGEM FINAL - Remove duplicatas e limpa
            unique_skills = list(dict.fromkeys(skills_data))
            clean_skills = [skill for skill in unique_skills if self.is_clean_skill(skill)]
            
            print(f"‚úÖ {len(clean_skills)} compet√™ncias encontradas")
            return clean_skills
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao extrair compet√™ncias: {e}")
            return []

    def is_valid_skill_title(self, text):
        """Verifica se √© um t√≠tulo de compet√™ncia v√°lido"""
        if not text or len(text) < 2 or len(text) > 50:
            return False
        
        text_lower = text.lower()
        
        # üö´ EXCLUS√ïES ABSOLUTAS - Interface e se√ß√µes
        hard_excludes = [
            'mensagens', 'notifica√ß√µes', 'eu', 'para neg√≥cios', 'premium',
            'conex√µes', 'coment√°rio', 'seguem esta p√°gina', 'experimente',
            'ver mais', 'exibir todas', 'recomendar compet√™ncia',
            'todos', 'compet√™ncias', 'skills', 'conhecimentos',
            'recomendar', 'experi√™ncias', 'experi√™ncia', 'recomenda√ß√µes'
        ]
        
        if any(exclude in text_lower for exclude in hard_excludes):
            return False
        
        # ‚úÖ DEVE SER UM NOME DE COMPET√äNCIA
        return (
            len(text.split()) <= 5 and           # M√°ximo 5 palavras
            not text.isdigit() and               # N√£o √© s√≥ n√∫mero
            not text[0].isdigit() and            # N√£o come√ßa com n√∫mero
            any(char.isalpha() for char in text) # Tem pelo menos uma letra
        )

    def is_clean_skill(self, text):
        """Limpeza final da compet√™ncia"""
        # Remove n√∫meros no in√≠cio (ex: "1. JavaScript" ‚Üí "JavaScript")
        clean_text = re.sub(r'^\d+\.\s*', '', text.strip())
        
        # Remove textos muito curtos ap√≥s limpeza
        if len(clean_text) < 2:
            return False
        
        # Remove compet√™ncias que s√£o nomes de empresas/universidades
        company_indicators = ['universidade', 'faculdade', 'col√©gio', 'escola', 'instituto']
        if any(indicator in clean_text.lower() for indicator in company_indicators):
            return False
        
        return clean_text

    def clean_experience_text(self, text):
        """Limpa texto de experi√™ncia"""
        lines = text.split('\n')
        clean_lines = []
        
        for line in lines:
            line_clean = line.strip()
            if (line_clean and 
                len(line_clean) > 5 and
                not any(exclude in line_clean.lower() for exclude in [
                    'conectar', 'seguir', 'ver mais', '...', 'mensagens',
                    'atualiza√ß√µes do feed', 'feed', 'notifica√ß√µes', 'in√≠cio', 
                    'minha rede', 'atualiza√ß√£o de rede'
                ])):
                clean_lines.append(line_clean)
        
        return ' | '.join(clean_lines[:4]) if clean_lines else None

    def clean_education_text(self, text):
        """Limpa texto de educa√ß√£o"""
        lines = text.split('\n')
        clean_lines = []
        
        for line in lines:
            line_clean = line.strip()
            if (line_clean and 
                len(line_clean) > 5 and
                not any(exclude in line_clean.lower() for exclude in [
                    'conectar', 'seguir', 'ver mais', '...', 'mensagens',
                    'atualiza√ß√µes do feed', 'feed', 'notifica√ß√µes', 'in√≠cio', 
                    'minha rede', 'atualiza√ß√£o de rede'
                ])):
                clean_lines.append(line_clean)
        
        return ' | '.join(clean_lines[:3]) if clean_lines else None

    def filter_interface_content(self, data_list):
        """Filtra conte√∫do de interface como 'atualiza√ß√µes do feed'"""
        if not data_list or data_list[0] in ["Experi√™ncia n√£o encontrada", "Forma√ß√£o n√£o encontrada"]:
            return data_list
        
        filtered_data = []
        for item in data_list:
            # Remove itens que cont√™m padr√µes de interface/feed
            if not any(pattern in item.lower() for pattern in [
                'atualiza√ß√µes do feed', 
                'feed', 
                'notifica√ß√µes',
                'in√≠cio', 
                'minha rede',
                'atualiza√ß√£o de rede'
            ]):
                filtered_data.append(item)
        
        return filtered_data if filtered_data else ["N√£o informado"]

    def show_detailed_results(self, profile_data):
        """Mostra resultados formatados"""
        print("\n" + "=" * 70)
        print("üìä DADOS REAIS DO PERFIL")
        print("=" * 70)
        
        print(f"üë§ NOME: {profile_data.get('nome', 'N/A')}")
        print(f"üíº CARGO ATUAL: {profile_data.get('cargo_atual', 'N/A')}")
        print(f"üìç LOCALIZA√á√ÉO: {profile_data.get('localizacao', 'N/A')}")
        
        sobre = profile_data.get('sobre', 'N/A')
        print(f"\nüìù SOBRE:")
        print("-" * 40)
        if sobre != "N/A" and sobre != "Se√ß√£o n√£o encontrada":
            print(f"   {sobre}")
        else:
            print("   N√£o informado")
        print("-" * 40)
        
        # EXPERI√äNCIA - COM FILTRO
        experiencias = self.filter_interface_content(profile_data.get('experiencia_principal', []))
        print(f"\nüíº EXPERI√äNCIA ({len(experiencias)}):")
        print("-" * 40)
        if experiencias and experiencias[0] != "N√£o informado":
            for i, exp in enumerate(experiencias, 1):
                print(f"   {i}. {exp}")
        else:
            print("   N√£o informado")
        print("-" * 40)
        
        # FORMA√á√ÉO - COM FILTRO
        formacao = self.filter_interface_content(profile_data.get('formacao_academica', []))
        print(f"\nüéì FORMA√á√ÉO ({len(formacao)}):")
        print("-" * 40)
        if formacao and formacao[0] != "N√£o informado":
            for i, edu in enumerate(formacao, 1):
                print(f"   {i}. {edu}")
        else:
            print("   N√£o informado")
        print("-" * 40)
        
        # üÜï COMPET√äNCIAS - PRECISAS
        competencias = profile_data.get('competencias_principais', [])
        print(f"\nüõ†Ô∏è  COMPET√äNCIAS:")
        print("-" * 40)
        if competencias and competencias[0] not in ["Compet√™ncias n√£o encontradas", "Erro ao buscar compet√™ncias"]:
            for i, skill in enumerate(competencias, 1):
                print(f"   üéØ {skill}")
                if i < len(competencias):  # Linha em branco entre compet√™ncias
                    print()
        else:
            print("   N√£o informado")
        print("-" * 40)
        
        print("=" * 70)

    def save_data(self, data, filename="linkedin_data.json"):
        """Salva dados em JSON"""
        try:
            existing_data = []
            if os.path.exists(filename):
                with open(filename, 'r', encoding='utf-8') as f:
                    existing_data = json.load(f)
            
            if isinstance(data, list):
                existing_data.extend(data)
            else:
                existing_data.append(data)
            
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(existing_data, f, ensure_ascii=False, indent=2)
            
            print(f"üíæ Dados salvos: {filename}")
            
        except Exception as e:
            print(f"‚ö†Ô∏è  Erro ao salvar: {e}")

    def close(self):
        """Fecha o navegador"""
        try:
            self.driver.quit()
            print("üîö NAVEGADOR FECHADO")
        except:
            pass

# PROGRAMA PRINCIPAL
def main():
    print("=" * 50)
    print("üöÄ LINKEDIN SCRAPER - COMPET√äNCIAS PRECISAS")
    print("üéØ Foca APENAS na se√ß√£o correta de compet√™ncias")
    print("=" * 50)
    
    scraper = None
    
    try:
        scraper = LinkedInScraperPro()
        
        print("\nüîê FAZENDO LOGIN...")
        scraper.login_linkedin()
        
        while True:
            print("\n" + "=" * 40)
            print("üéØ MENU PRINCIPAL")
            print("=" * 40)
            print("1. üîç Coletar perfil √∫nico")
            print("2. üö™ Sair")
            print("=" * 40)
            
            opcao = input("üëâ Op√ß√£o: ").strip()
            
            if opcao == "1":
                url = input("üîó URL do perfil: ").strip()
                if url:
                    data = scraper.get_dynamic_profile_data(url)
                    if data:
                        scraper.save_data(data)
                        scraper.show_detailed_results(data)
                    else:
                        print("‚ùå Falha na coleta - verifique a URL")
                else:
                    print("‚ùå URL vazia")
            
            elif opcao == "2":
                print("üëã Saindo...")
                break
            
            else:
                print("‚ùå Op√ß√£o inv√°lida")
        
    except Exception as e:
        print(f"üí• ERRO: {e}")
    finally:
        if scraper:
            scraper.close()

if __name__ == "__main__":
    main()